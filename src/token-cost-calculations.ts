// token-cost-calculations.ts
// Calculates token costs for LLM requests based on model and token usage

// Import the model prices data
import { modelPricesData as rawModelPricesData } from './data/model-prices';

// Define the type for the model pricing map
type ModelPricingRawMap = Record<string, ModelPricingRaw>

/**
 * Interface for model pricing information from the JSON file
 */
export interface ModelPricingRaw {
  max_tokens?: string | number
  max_input_tokens?: string | number
  max_output_tokens?: string | number
  input_cost_per_token: number
  output_cost_per_token: number
  input_cost_per_token_batches?: number
  output_cost_per_token_batches?: number
  cache_read_input_token_cost?: number
  cache_creation_input_token_cost?: number
  input_cost_per_audio_token?: number
  output_cost_per_audio_token?: number
  litellm_provider?: string
  mode?: string
  supports_function_calling?: boolean
  supports_parallel_function_calling?: boolean
  supports_vision?: boolean
  supports_audio_input?: boolean
  supports_audio_output?: boolean
  supports_prompt_caching?: boolean
  supports_response_schema?: boolean
  supports_system_messages?: boolean
  deprecation_date?: string
  [key: string]: any // Allow for additional properties
}

/**
 * Interface for normalized model pricing information
 */
export interface ModelPricing {
  input_cost_per_token: number
  output_cost_per_token: number
  cache_read_input_token_cost?: number
  cache_creation_input_token_cost?: number
}

// Cast the imported data to the correct type
const modelPricesData: Record<string, ModelPricingRaw> = rawModelPricesData as unknown as Record<string, ModelPricingRaw>

/**
 * Interface for token usage information with standardized field names
 */
export interface TokenUsage {
  // New tokens in the prompt (not from cache)
  promptCacheMissTokens: number
  // Tokens read from cache
  promptCacheHitTokens: number
  // Output tokens generated by the model for reasoning
  reasoningTokens: number
  // Output tokens generated by the model for completion
  completionTokens: number
  // Total output tokens (reasoning + completion)
  totalOutputTokens: number
  // Total input tokens (cache miss + cache hit)
  totalInputTokens: number
  // Tokens written to cache for future use
  promptCacheWriteTokens: number
}

/**
 * Interface for cost breakdown
 */
export interface CostBreakdown {
  inputCost: number
  outputCost: number
  cacheReadCost: number
  cacheWriteCost: number
  totalCost: number
}

/**
 * Interface for savings analysis
 */
export interface SavingsAnalysis {
  inputSavings: number
  totalSavings: number
  percentSaved: number
}

/**
 * Interface for cache statistics
 */
export interface CacheStatistics {
  hitRate: number
  totalInputTokens: number
  cachedTokens: number
  uncachedTokens: number
}

/**
 * Interface for comprehensive cost analysis result
 */
export interface RequestCostAnalysis {
  actualCost: CostBreakdown
  uncachedCost: CostBreakdown
  savings: SavingsAnalysis
  cacheStats: CacheStatistics
}

/**
 * Get the model pricing information for a specific model
 * @throws Error if model pricing is not found
 */
export function getModelPricing(model: string): ModelPricing {
  // Normalize model name (remove any version suffixes, etc.)
  const normalizedModel = model.toLowerCase().trim()

  // Try to find an exact match
  if (normalizedModel in modelPricesData) {
    return modelPricesData[normalizedModel] as ModelPricing
  }

  // Try to find a match by comparing the model name without provider prefix
  for (const knownModel of Object.keys(modelPricesData)) {
    const knownModelWithoutProvider = knownModel.split('/').pop()?.toLowerCase()
    if (knownModelWithoutProvider === normalizedModel) {
      return modelPricesData[knownModel] as ModelPricing
    }
  }

  // Throw an error if model pricing is not found
  throw new Error(`Model pricing not found for "${model}". Please update the model prices data.`)
}

/**
 * Calculate comprehensive cost analysis for a request based on token usage
 * @param model The model name used for the request
 * @param promptCacheMissTokens Number of tokens not served from cache
 * @param totalOutputTokens Total output tokens generated
 * @param promptCacheHitTokens Number of tokens served from cache (default: 0)
 * @param promptCacheWriteTokens Number of tokens written to cache (default: 0)
 * @returns Comprehensive cost analysis including actual cost, uncached cost, savings, and cache stats
 */
export function calculateRequestCost(
  model: string,
  promptCacheMissTokens: number,
  totalOutputTokens: number,
  promptCacheHitTokens: number = 0,
  promptCacheWriteTokens: number = 0,
): RequestCostAnalysis {
  // Get model pricing
  const pricing = getModelPricing(model)

  // Calculate actual costs (with caching applied)
  const actualInputCost = promptCacheMissTokens * pricing.input_cost_per_token
  const actualOutputCost = totalOutputTokens * pricing.output_cost_per_token
  const cacheReadRate = pricing.cache_read_input_token_cost || 0
  const cacheReadCost = promptCacheHitTokens * cacheReadRate
  const cacheWriteRate = pricing.cache_creation_input_token_cost || 0
  const cacheWriteCost = promptCacheWriteTokens * cacheWriteRate
  const actualTotalCost = actualInputCost + actualOutputCost + cacheReadCost + cacheWriteCost

  // Calculate uncached costs (as if no caching was used)
  const totalInputTokens = promptCacheMissTokens + promptCacheHitTokens
  const uncachedInputCost = totalInputTokens * pricing.input_cost_per_token
  const uncachedOutputCost = totalOutputTokens * pricing.output_cost_per_token
  const uncachedTotalCost = uncachedInputCost + uncachedOutputCost

  // Calculate savings
  const inputSavings = uncachedInputCost - actualInputCost
  const totalSavings = uncachedTotalCost - actualTotalCost
  const percentSaved = uncachedTotalCost > 0 ? (totalSavings / uncachedTotalCost) * 100 : 0

  // Calculate cache statistics
  const hitRate = totalInputTokens > 0 ? promptCacheHitTokens / totalInputTokens : 0

  return {
    actualCost: {
      inputCost: actualInputCost,
      outputCost: actualOutputCost,
      cacheReadCost,
      cacheWriteCost,
      totalCost: actualTotalCost,
    },
    uncachedCost: {
      inputCost: uncachedInputCost,
      outputCost: uncachedOutputCost,
      cacheReadCost: 0,
      cacheWriteCost: 0,
      totalCost: uncachedTotalCost,
    },
    savings: {
      inputSavings,
      totalSavings,
      percentSaved,
    },
    cacheStats: {
      hitRate,
      totalInputTokens,
      cachedTokens: promptCacheHitTokens,
      uncachedTokens: promptCacheMissTokens,
    },
  }
}
